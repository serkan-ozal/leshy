{"name":"Leshy","tagline":"Leshy is a framework for replacing default Java serialization with your custom implementation on the fly without any code change in your application by using Java Instrumentation API.  ","body":"## **What is Leshy?** \r\n\r\n_Leshy_ is a framework for replacing default Java serialization with your custom implementation on the fly without any code change in your application by using _Java Instrumentation API_. Leshy doesn't require any startup parameter for using _Java Instrumentation API_. It loads its java agent on the fly when it is needed. With Leshy, you can customize and intercept Java serialization/deserialization logic on the fly. Suppose that you are working on a project and serialization/deserialization codes are splitted into all code by using **\"java.io.ObjectOutputStream\"** for serialization and **\"java.io.ObjectInputStream\"** for deserialization. With _Leshy_ you can replace all serialization/deserialization logic with zero code change in your application. \r\n\r\n## **What does Leshy mean?**\r\n\r\nThe Leshy is a male woodland spirit in Slavic mythology who protects wild animals and forests.\r\n\r\n## **What features does Leshy have?**\r\n\r\n* You can inject your custom serializer/deserializers to default Java serialization/deserialization flow by specifying their conditions for using.\r\n\r\n* You can use default Java serialization/deserialization logic in your custom  serialization/deserialization flow.\r\n\r\n* You can switch JVM to default serialization/deserialization flow on the fly.\r\n\r\n* You can enable \"serialization for all types\" mode and so all non serializable classes (not implements **\"java.io.Serializable\"** interface) can be serialized/deserialized by default Java serialization/deserialization flow with no code change.\r\n\r\n## **Install**\r\n\r\nIn your **pom.xml**, you must add repository and dependency for _Leshy_. \r\nYou can change **\"leshy.version\"** to any existing _Leshy_ library version.\r\n\r\n\t...\r\n\t<properties>\r\n\t\t...\r\n\t\t<leshy.version>1.0.0-RELEASE</leshy.version>\r\n\t\t...\r\n\t</properties>\r\n\t...\r\n\t<dependencies>\r\n\t\t...\r\n\t\t<dependency>\r\n\t\t\t<groupId>tr.com.serkanozal</groupId>\r\n\t\t\t<artifactId>leshy</artifactId>\r\n\t\t\t<version>${leshy.version}</version>\r\n\t\t</dependency>\r\n\t\t...\r\n\t</dependencies>\r\n\t...\r\n\t<repositories>\r\n\t\t...\r\n\t\t<repository>\r\n\t\t\t<id>serkanozal-maven-repository</id>\r\n\t\t\t<url>https://github.com/serkan-ozal/maven-repository/raw/master/</url>\r\n\t\t</repository>\r\n\t\t...\r\n\t</repositories>\r\n\t...\r\n\r\n\r\n## **Leshy with simple examples**\r\n  \r\n### **Custom Serialization/Deserialization Examples**\r\n\r\nHere is **\"ClassToSerialize\"** class to using in serialization/deserialization samples:  \r\n\r\n    public class ClassToSerialize implements Serializable {\r\n\r\n        ...\r\n\t\r\n        private byte byteValue = 1;\r\n        private boolean booleanValue = true;\r\n        private char charValue = 'X';\r\n        private short shortValue = 10;\r\n        private int intValue = 100;\r\n        private float floatValue = 200.0F;\r\n        private long longValue = 1000;\r\n        private double doubleValue = 2000.0;\r\n        private String stringValue = \"str\";\r\n\r\n        ...\r\n\r\n    } \r\n\r\nIn this demo, our custom serialization/deserialization logic is injected only for **\"ClassToSerialize\"** class.\r\n\r\n    public class LeshySerializationDeserializationDemoWithCustomSerializationLogic {\r\n\r\n        public static void main(String[] args) throws IOException, ClassNotFoundException {\r\n            serializeAndDeserializeByUsingCustomSerializationLogicWithCustomSerDe();\r\n        }\r\n\t\r\n        public static void serializeAndDeserializeByUsingCustomSerializationLogicWithCustomSerDe() throws IOException, ClassNotFoundException {\r\n            SerDeService serdeService = SerDeServiceFactory.getSerdeService();\r\n            serdeService.\r\n                registerSerDe(\r\n                    new SerDeDispatcher(\r\n                        new ClassFilter(ClassToSerialize.class), \r\n                        new CustomSerDe())).\r\n                setup();\r\n\t\t\r\n            ClassToSerialize serializedObject = new ClassToSerialize().randomize();\r\n\t\t\r\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(bos);\r\n            oos.writeObject(serializedObject);\r\n            bos.flush();\r\n\r\n            byte[] objectContent = bos.toByteArray();\r\n\t\t\r\n            ByteArrayInputStream bis = new ByteArrayInputStream(objectContent);\r\n            ObjectInputStream ois = new ObjectInputStream(bis);\r\n            ClassToSerialize deserializedObject = (ClassToSerialize) ois.readObject();\r\n        }\r\n\t\r\n        private static class CustomSerDe implements SerDe {\r\n\r\n            @Override\r\n            public void serialize(final Object obj, final OutputStream os) throws IOException {\r\n                // Write your custom serialization logic\r\n            }\r\n\r\n            @Override\r\n            public Object deserialize(final InputStream is) throws IOException, ClassNotFoundException {\r\n\t        // Write your custom deserialization logic\r\n            }\r\n\t\t\r\n        }\r\n\t\r\n    } \r\n\r\nThis demo is about using default Java serialization/deserialization logic in our custom serialization/deserialization logic.\r\n\r\n    public class CustomSerDe implements SerDe {\r\n\r\n        private SerDeService serdeService;\r\n\t\t\r\n        public CustomSerDe(SerDeService serdeService) {\r\n            this.serdeService = serdeService;\r\n        }\r\n\t\t\r\n        @Override\r\n        public void serialize(final Object obj, final OutputStream os) throws IOException {\r\n            serdeService.runInSandbox(\r\n                new SerializationSandbox() {\r\n                    @Override\r\n                    public void runInSandbox() {\r\n                        try {\r\n                            new ObjectOutputStream(os).writeObject(obj);\r\n                        }\r\n                        catch (Throwable t) {\r\n                            t.printStackTrace();\r\n                            throw new RuntimeException(t);\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        @Override\r\n        public Object deserialize(final InputStream is) throws IOException, ClassNotFoundException {\r\n            return \r\n                serdeService.runInSandbox(\r\n                    new DeserializationSandbox() {\r\n                        @Override\r\n                        public Object runInSandbox() {\r\n                            try {\r\n                                return new ObjectInputStream(is).readObject();\r\n                            } \r\n                            catch (Throwable t) {\r\n                                t.printStackTrace();\r\n                                throw new RuntimeException(t);\r\n                            }\r\n                        }\r\n                    }\r\n                );\r\n        }\t\r\n    } \r\n\r\n### **Hacking JVM for Serialize and Deserialize Non-Serializable Classes**\r\n\r\nHere is **\"UnserializableClass\"** class (note that not implements **\"java.io.Serializable\"** interface) for using in \"serialization for all type\" mode sample:  \r\n \r\n    public class UnserializableClass {\r\n\r\n        ...\r\n\t\r\n        private byte byteValue = 1;\r\n        private boolean booleanValue = true;\r\n        private char charValue = 'X';\r\n        private short shortValue = 10;\r\n        private int intValue = 100;\r\n        private float floatValue = 200.0F;\r\n        private long longValue = 1000;\r\n        private double doubleValue = 2000.0;\r\n        private String stringValue = \"str\";\r\n\r\n        ...\r\n\r\n    }  \r\n\r\nDefault Java serialization/deserialization flow doesn't allow using non-serializable classes (not implements **\"java.io.Serializable\"** interface). But with Leshy's \"serialization for all types\" mode, JVM is hacked and all classes (serializable or non-serializable) can be serialized or deserialized by default Java serialization/deserialization flow. In addition, you can invert JVM to default mode with _Leshy_ on the fly.\r\n\r\n    SerDeService serdeService = SerDeServiceFactory.getSerdeService();\r\n    serdeService.serializationOpenForAllTypes();\r\n\t\t\t\r\n    UnserializableClass serializedObject = new UnserializableClass().randomize();\r\n\t\t\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    ObjectOutputStream oos = new ObjectOutputStream(bos);\r\n    oos.writeObject(serializedObject);\r\n    bos.flush();\r\n\r\n    byte[] objectContent = bos.toByteArray();\r\n\t\t\r\n    ByteArrayInputStream bis = new ByteArrayInputStream(objectContent);\r\n    ObjectInputStream ois = new ObjectInputStream(bis);\r\n    UnserializableClass deserializedObject = (UnserializableClass) ois.readObject();\r\n\r\n    serdeService.serializationOpenOnlyForSerializableTypes();\r\n\r\nYou can find all demo codes (including these samples above) at [https://github.com/serkan-ozal/leshy/tree/master/src/test/java/tr/com/serkanozal/leshy/demo](https://github.com/serkan-ozal/leshy/tree/master/src/test/java/tr/com/serkanozal/leshy/demo)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}